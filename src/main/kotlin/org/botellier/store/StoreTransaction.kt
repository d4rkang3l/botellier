package org.botellier.store

/**
 * Class for managing transactions in the given store (a.k.a. MapValue). All the functions
 * (except commit) are not applied directly, they are instead saved to a cache and applied
 * when calling commit.
 */
class StoreTransaction(val initialStore: MapValue) {
    val changes = mutableListOf<StoreChange>()
    private val store = initialStore
    val cache = initialStore.clone().map

    /**
     * Returns the value at the given key. This function doesn't really make any changes,
     * it is there just for convenience.
     * @param key the key to lookup for.
     * @returns the StoreValue in the underlying store.
     */
    fun get(key: String): StoreValue {
        return cache.get(key) ?: NilValue()
    }

    /**
     * Sets the value of the given key to the given value. If the key already
     * exists throws an exception.
     * @param key the key to set.
     * @param value the value to use.
     * @returns
     */
    fun set(key: String, value: StoreValue) {
        val current = cache.get(key) ?: NilValue()
        dispatch(key, current, value)
    }

    /**
     * Updates an existing key, sending the current value to the lambda
     * function and using its return value as the new value. Updating
     * and setting a key to a NilValue is the same as deleting it.
     * @param key the key to update.
     * @param block the lambda function that receives the old value and returns the new value.
     * @throws StoreException.InvalidTypeException if the key to update doesn't exists or if the requested value is a
     * different type.
     */
    inline fun <reified T: StoreValue> update(key: String, block: (T) -> StoreValue): StoreValue {
        val value = cache.get(key) ?: NilValue()
        if (value !is NilValue) {
            if (value is T) {
                val nextValue = block(value)
                dispatch(key, value, nextValue)
                return nextValue
            } else {
                throw StoreException.InvalidTypeException(key, value::class.qualifiedName!!)
            }
        } else {
            throw StoreException.InvalidTypeException(key, NilValue::class.qualifiedName!!)
        }
    }

    /**
     * Works just like updates, the only difference is that that the key to update
     * may or may not exist already.
     * @param key the key to update.
     * @param block the lambda function that receives the nullable old value and returns the new value.
     * @throws StoreException.InvalidTypeException if the requested value is a different type.
     */
    inline fun <reified T: StoreValue> mupdate(key: String, block: (T?) -> StoreValue): StoreValue {
        val value = cache.get(key) ?: NilValue()
        if (value !is NilValue) {
            if (value is T) {
                val nextValue = block(value)
                dispatch(key, value, nextValue)
                return nextValue
            } else {
                throw StoreException.InvalidTypeException(key, value::class.qualifiedName!!)
            }
        } else {
            val nextValue = block(null)
            dispatch(key, value, nextValue)
            return nextValue
        }
    }

    /**
     * Deletes the value at the given key.
     * @param key the key to delete.
     * @returns the value of the key to be deleted.
     */
    fun delete(key: String): StoreValue {
        val value = cache.remove(key) ?: NilValue()
        dispatch(key, value, NilValue())
        return value
    }

    /**
     * Begins a transaction that is automatically commited before returning.
     * @param block the extension lambda
     */
    fun begin(block: StoreTransaction.() -> Unit) {
        this.block()
        this.commit()
    }

    /**
     * Commits the changes generated by this transaction. Logging all the changes
     * to the underlying store's log.
     */
    fun commit() {
        // Logs changes.
        // TODO: Log changes.

        // Applies changes to store.
        for (change in changes) {
            when (change.action) {
                StoreChange.Action.SET -> {
                    store.map.set(change.key, change.after)
                }
                StoreChange.Action.DELETE -> {
                    store.map.remove(change.key)
                }
            }
        }

        changes.clear()
    }

    /**
     * Decides whenever to set or delete a key based on next value.
     * @param key the key to take the action on.
     * @param before the data that was in the key before.
     * @param after the new data of the key.
     */
    fun dispatch(key: String, before: StoreValue, after: StoreValue) {
        if (after is NilValue || after.isEmpty()) {
            cache.remove(key)
            changes.add(StoreChange(
                    StoreChange.Action.DELETE,
                    key,
                    before,
                    NilValue()
            ))
        } else {
            cache.set(key, after)
            changes.add(StoreChange(
                    StoreChange.Action.SET,
                    key,
                    before,
                    after
            ))
        }
    }
}

/**
 * Class that represents a single action on a key (SET or DELETE). Note that
 * a StoreChange's SET can be used for both setting or updating a value.
 */
data class StoreChange(val action: Action, val key: String, val before: StoreValue, val after: StoreValue) {
    enum class Action {
        SET, DELETE
    }
}

/**
 * Checks if the given value is empty (empty lists, empty strings, etc).
 * @param value the value to check.
 * @returns true if the value is empty.
 */
private fun StoreType.isEmpty(): Boolean {
    return when (this) {
        is StringValue -> this.value.isEmpty()
        is ListValue -> this.list.isEmpty()
        is SetValue -> this.set.isEmpty()
        is MapValue -> this.map.isEmpty()
        else -> false
    }
}
