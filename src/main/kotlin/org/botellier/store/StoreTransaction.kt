package org.botellier.store

import org.botellier.log.Log
import org.botellier.serializer.toByteArray
import org.botellier.value.*

/**
 * Class for managing transactions in the given store (a.k.a. MapValue). All the functions
 * (except commit) are not applied directly, they are instead saved to a cache and applied
 * when calling commit.
 */
class StoreTransaction(initialStore: MapValue) {
    private val changes = mutableListOf<StoreChange>()
    private val map = initialStore.unwrap()
    private val cache = initialStore.clone().unwrap()

    /**
     * Returns the value at the given key. This function doesn't really make any changes,
     * it is there just for convenience.
     * @param key the key to lookup for.
     * @returns the StoreValue in the underlying store.
     */
    fun get(key: String): StoreValue {
        return cache.get(key) ?: map.get(key) ?: NilValue()
    }

    /**
     * Sets the value of the given key to the given value. If the key already
     * exists throws an exception.
     * @param key the key to set.
     * @param value the value to use.
     * @returns
     */
    fun set(key: String, value: StoreValue) {
        val current = cache.get(key) ?: NilValue()
        dispatch(key, current, value)
    }

    /**
     * Updates an existing key, sending the current value to the lambda
     * function and using its return value as the new value. Updating
     * and setting a key to a NilValue is the same as deleting it.
     * @param key the key to update.
     * @param block the lambda function that receives the old value and returns the new value.
     * @throws StoreException.InvalidTypeException if the key to update doesn't exists or if the requested value is a
     * different type.
     */
    inline fun <reified T: StoreValue> update(key: String, block: (T) -> StoreValue): StoreValue {
        val value = get(key)
        if (value !is NilValue) {
            if (value is T) {
                val nextValue = block(value)
                dispatch(key, value, nextValue)
                return nextValue
            } else {
                throw StoreException.InvalidTypeException(key, value::class.qualifiedName!!)
            }
        } else {
            throw StoreException.InvalidTypeException(key, NilValue::class.qualifiedName!!)
        }
    }

    /**
     * Works just like update, the only difference is that that the key to update
     * may or may not exist already.
     * @param key the key to update.
     * @param block the lambda function that receives the nullable old value and returns the new value.
     * @throws StoreException.InvalidTypeException if the requested value is a different type.
     */
    inline fun <reified T: StoreValue> mupdate(key: String, block: (T?) -> StoreValue): StoreValue {
        val value = get(key)
        if (value !is NilValue) {
            if (value is T) {
                val nextValue = block(value)
                dispatch(key, value, nextValue)
                return nextValue
            } else {
                throw StoreException.InvalidTypeException(key, value::class.qualifiedName!!)
            }
        } else {
            val nextValue = block(null)
            dispatch(key, value, nextValue)
            return nextValue
        }
    }

    /**
     * Deletes the value at the given key.
     * @param key the key to delete.
     * @returns the value of the key to be deleted.
     */
    fun delete(key: String): StoreValue {
        val value = cache.remove(key) ?: NilValue()
        dispatch(key, value, NilValue())
        return value
    }

    /**
     * Begins a transaction block that is cleared before starting,
     * and committed before returning. Useful for expressions like
     * the following:
     *
     * ```
     * transaction.begin {
     *     set("one", IntValue(1))
     *     set("two", IntValue(2))
     * }
     * ```
     *
     * Instead of:
     *
     * ```
     * transaction.rollback()
     * transaction.set("one", IntValue(1))
     * transaction.set("two", IntValue(2))
     * transaction.commit()
     * ```
     *
     * @param block the extension lambda
     * @returns a reference to the same transaction in use.
     */
    fun begin(block: StoreTransaction.() -> Unit) {
        this.rollback()
        this.block()
        this.commit()
    }

    /**
     * Commits the changes generated by this transaction. Logging all the changes
     * to the underlying store's log.
     * @param log the optional Log that can be used to log the changes.
     */
    fun commit(log: Log? = null) {
        // Logs changes.
        if (log != null) {
            for ((action, key, before, after) in changes) {
                when (action) {
                    StoreChange.Action.SET -> {
                        log.set(key, before.toByteArray(), after.toByteArray())
                    }
                    StoreChange.Action.DELETE -> {
                        log.delete(key)
                    }
                }
            }
        }

        // Applies changes to store.
        for ((action, key, before, after) in changes) {
            when (action) {
                StoreChange.Action.SET -> {
                    map.set(key, after)
                }
                StoreChange.Action.DELETE -> {
                    map.remove(key)
                }
            }
        }

        changes.clear()
    }

    /**
     * Clears all the changes in the transaction.
     */
    fun rollback() {
        this.changes.clear()
        this.cache.clear()
    }

    /**
     * Decides whenever to set or delete a key based on next value.
     * @param key the key to take the action on.
     * @param before the data that was in the key before.
     * @param after the new data of the key.
     */
    fun dispatch(key: String, before: StoreValue, after: StoreValue) {
        if (after is NilValue || after.isEmpty()) {
            cache.remove(key)
            changes.add(StoreChange(
                    StoreChange.Action.DELETE,
                    key,
                    before,
                    NilValue()
            ))
        } else {
            cache.set(key, after)
            changes.add(StoreChange(
                    StoreChange.Action.SET,
                    key,
                    before,
                    after
            ))
        }
    }
}

/**
 * Class that represents a single action on a key (SET or DELETE). Note that
 * a StoreChange's SET can be used for both setting or updating a value.
 */
data class StoreChange(val action: Action, val key: String, val before: StoreValue, val after: StoreValue) {
    enum class Action {
        SET, DELETE
    }
}

/**
 * Checks if the given value is empty (empty lists, empty strings, etc).
 * @param value the value to check.
 * @returns true if the value is empty.
 */
private fun StoreType.isEmpty(): Boolean {
    return when (this) {
        is StringValue -> this.unwrap().isEmpty()
        is ListValue -> this.unwrap().isEmpty()
        is SetValue -> this.unwrap().isEmpty()
        is MapValue -> this.unwrap().isEmpty()
        else -> false
    }
}
